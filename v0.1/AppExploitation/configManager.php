<?php

trait TraitPath {

    private $pathCyptedNameKey;
    private $pathCyptedName;
    private $pathCyptedUuiKey;
    private $pathCyptedUui;
    private $pathDecyptedName;
    private $pathDecyptedUui;

    public function pathSet() {

        $this->pathCyptedName    = FrameWork::pathCyptedSet(self::SEC_TYPE);
        $this->pathCyptedNameKey = FrameWork::pathKeyGet($this->pathCyptedName);
        $this->pathCyptedUui     = FrameWork::uuidCyptedSet(self::SEC_TYPE);
        $this->pathCyptedUuiKey  = FrameWork::uuidKeyGet($this->pathCyptedUui);
        $this->pathDecyptedName  = FrameWork::secD($this->pathCyptedName, $this->pathCyptedNameKey);
        $this->pathDecyptedUui   = FrameWork::secD($this->pathCyptedUui, $this->pathCyptedUuiKey);

        return true;
    }
}

class Index {

    use TraitPath;

    CONST SEC_TYPE = 'I';

    private $name;

    public function __construct($conf) {

        $this->name = $conf->return;

        $this->pathSet();
    }
}

class Attribut extends Index {

    use TraitPath;

    CONST SEC_TYPE = 'A';

    private $type;
    private $testFunc;
    private $testResult;
    private $defaultValue;
    private $emptyValue;
    private $errorValue;
    private $value;
    private $setOnMatch   = false;
    private $defaultState = false;
    private $emptyState   = false;
    private $errorState   = false;

    public function __construct($conf) {

        parent::__construct($conf);

        $this->type = $conf->returnType;
        $testType   = ucfirst(strtolower($this->type));

        if(isset($conf->returnDefaultValue) === true) $this->defaultValue = $conf->returnDefaultValue;
        if(isset($conf->returnEmptyValue)   === true) $this->emptyValue   = $conf->returnEmptyValue;
        if(isset($conf->returnErrorValue)   === true) $this->errorValue   = $conf->returnErrorValue;

        if($testType === false)                $testType         = FrameWork::TYPE_MIXTED;
        if(isset($conf->setOnMatch) === true ) $this->setOnMatch = $conf->setOnMatch;

        $this->testFunc = FrameWork::CODE_FUNC_TEST_PREFIX.$testType;

        $this->pathSet();
    }

    public static function listSetFromConf($conf) {

        $attributList    = array();
        $attributListTmp = FrameWork::confToParamList($conf);

        foreach($attributListTmp as $k => $type) {

            $conf             = stdclass();
            $conf->return     = $k;
            $conf->returnType = $type;

            if(isset($conf->setOnMatch) === true ) $conf->setOnMatch = $conf->setOnMatch;

            $attributList[$k] = new Attribut($conf);
        }
        return $attributList;
    }
}

class Label {

    use TraitPath;

    CONST SEC_TYPE = 'L';

    private $name;
    private $attributList = array();

    public function __construct($conf) {

        $this->name         = $conf->return;
        $this->attributList = Attribut::listSetFromConf($conf);

        $this->pathSet();
    }
}

class MicroServiceReturn extends Attribut {

    CONST SEC_TYPE = 'MR';

    public function __construct($conf) {

        parent::__construct($conf);
    }
}

class MicroService {

    use TraitPath;

    CONST SEC_TYPE = 'M';

    private $name;
    private $return;
    private $attributList = array();

    public function __construct($name, $conf) {

        $this->name         = $name;
        $this->return       = new MicroServiceReturn($conf);
        $this->attributList = Attribut::listSetFromConf($conf);

        $this->pathSet();
    }
}

class RelationShip {

    use TraitPath;

    CONST SEC_TYPE = 'R';

    private $name;
    private $end;
    private $attributList = array();

    public function __construct($conf) {

        $this->name         = $conf->relationship;
        $this->attributList = Attribut::listSetFromConf($conf);

        if(isset($conf->end) == true) $this->end = $conf->end;

        $this->pathSet();
    }
}


class Node {

    use TraitPath;

    CONST SEC_TYPE = 'N';

    private $name;
    private $extend;
    private $attributList = array();

    public function __construct($conf) {

        $this->name         = $conf->return;
        $this->extend       = $conf->returnType;
        $this->attributList = Attribut::listSetFromConf($conf);

        $this->pathSet();
    }
}

trait TraitCodePhp {

    use TraitPath;

    CONST CODE_LANGUAGE_PHP = 'Php';

    public function attributCodePhp($attributObj){

        return $code;
    }

    public function methodCodePhp($methodObj){

        return $code;
    }

    public function classCodePhp($classObj){

        return $code;
    }

    public function microServiceCodePhp($microServiceObj){

        return $code;
    }
}

trait TraitCodeCypher {

    use TraitPath;

    CONST CODE_LANGUAGE_CYPHER = 'Cypher';

    public function attributCodePhp($attributObj){

        return $code;
    }

    public function methodCodePhp($methodObj){

        return $code;
    }

    public function classCodePhp($classObj){

        return $code;
    }

    public function microServiceCodePhp($microServiceObj){

        return $code;
    }
}

class FrameWork {

    use TraitCodePhp;

    CONST CONF_FILE                   = 'conf/confManager.json';
    CONST CODE_PREFIX                 = 'Code';
    CONST CODE_FUNC_TEST_PREFIX       = 'traitTest';
    CONST TYPE_MIXTED                 = 'Mixted';
    CONST SEC_SALT_EXIPRE_DATE_FORMAT = 'Ym';
    CONST SEC_SALT_FILE_BASENAME      = 'secSalt';
    CONST SEC_KEY_UUID_FILE_BASENAME  = 'secUuid';
    CONST SEC_ITERATION_UUID          = 1000;
    CONST SEC_PACK_UUID               = 'H*';
    CONST SEC_ALGORITHM_UUID          = 'sha256';
    CONST SEC_UUID_RAND_START         = 20;
    CONST SEC_UUID_RAND_STOP          = 8000;
    CONST SEC_UUID_BASE_64_ENCODE     = false;
    CONST SEC_KEY_PATH_FILE_BASENAME  = 'secPath';
    CONST SEC_ITERATION_PATH          = 1000;
    CONST SEC_PACK_PATH               = 'H*';
    CONST SEC_ALGORITHM_PATH          = 'sha256';
    CONST SEC_PATH_RAND_START         = 10;
    CONST SEC_PATH_RAND_STOP          = 600;
    CONST SEC_PATH_BASE_64_ENCODE     = false;

    public static $codeLanguage       = self::CODE_LANGUAGE_PHP;
    public static $attributList       = array();
    public static $labelList          = array();
    public static $microServiceList   = array();
    public static $relationShipList   = array();
    public static $indexList          = array();
    public static $nodeList           = array();
    public static $keyList            = array();

    public function __construct($confFile = self::CONF_FILE) {

        $confContent = file_get_contents($confFile);
        $confObj     = json_decode($confContent);

        foreach($confObj->nodeList as $nodeVarName => $nodeConf) {

            $conf = self::nodeConfToLabelConf($nodeVarName, $nodeConf);

            self::nodeAdd($nodeConf, $conf);
        }
        foreach($confObj->microServiceDefaultList as $microserviceName => $microserviceConf) {

            self::attributAdd($microserviceConf);
            self::labelAdd($microserviceConf);
            self::microServiceAdd($microserviceName, $microserviceConf);
            self::relationShipAdd($microserviceConf);
        }
        foreach($confObj->indexList as $index) {

            self::indexAdd($index);
        }
    }

    private static function nodeConfToLabelConf($nodeVarName, $nodeConf) {

        $conf               = stdclass();
        $conf->postNameList = array();
        $conf->postTypeList = array();

        if(isset($conf->onCreateSetList) === true) {

            foreach($conf->onCreateSetList as $attributName => $attributDefaultValue) {

                $key                      = count($conf->postNameList);
                $conf->postNameList[$key] = $attributName;
                $type                     = gettype($attributDefaultValue);

                if($type === 'object') {

                    $type = get_class($attributDefaultValue);
                }
                $conf->postTypeList[$key] = $type;
            }
        }
        $conf->return      = $nodeVarName;
        $conf->returnType  = $nodeConf->label;

        return $conf;
    }

    private static function secC($value, $secKeyFileBasename, $iterations, $secPack, $secAlgorithm, $base64Encode = true){

        $salt       = file_get_contents(dirname(__FILE__).DIRECTORY_SEPARATOR.self::SEC_SALT_FILE_BASENAME.date(self::SEC_SALT_EXIPRE_DATE_FORMAT, time()));
        $keyBase    = file_get_contents(dirname(__FILE__).DIRECTORY_SEPARATOR.$secKeyFileBasename.date(self::SEC_SALT_EXIPRE_DATE_FORMAT, time()));
        $key        = pack($secPack, hash_pbkdf2($secAlgorithm, $keyBase, $salt, $iterations, 32));
        $iv_size    = mcrypt_get_iv_size(MCRYPT_RIJNDAEL_128, MCRYPT_MODE_CBC);
        $iv         = mcrypt_create_iv($iv_size, MCRYPT_RAND);
        $ciphertext = mcrypt_encrypt(MCRYPT_RIJNDAEL_128, $key, $value, MCRYPT_MODE_CBC, $iv);
        $ciphertext = $iv . $ciphertext;
        $crypted    = $ciphertext;

        if($base64Encode === true) $crypted = base64_encode($crypted);

        self::$keyList[$crypted]['KEY'] = $key;
        self::$keyList[$crypted]['IV']  = $iv;

        return $crypted;
    }

    private static function secD($value, $key){

        $ciphertext_dec = base64_decode($value);
        $iv_dec         = substr($ciphertext_dec, 0, $key['IV']);
        $ciphertext_dec = substr($ciphertext_dec, $key['IV']);

        return mcrypt_decrypt(MCRYPT_RIJNDAEL_128, $key['KEY'], $ciphertext_dec, MCRYPT_MODE_CBC, $iv_dec);
    }

    private static function uidGenSimple($type, $secRandStart = self::SEC_UUID_RAND_START, $secRandStop = self::SEC_UUID_RAND_STOP, $i = 4) {

        $value = rand($secRandStart, $secRandStop).$type.$i;

        while(isset(self::$nodeList[$value]) === true) {

            $i++;

            $value = rand($secRandStart, $secRandStop).$type.$i;
        }
    }

    private static function cryptSet($type, $secRandStart, $secRandStop, $secKeyFileBasename, $SecIteration, $secPack, $secAlgorithm, $secBase64Encode, $i = 0) {

        $value = rand($secRandStart, $secRandStop).$type.$i;

        while(isset(self::$nodeList[$value]) === true) {

            $i++;

            $value = rand($secRandStart, $secRandStop).$type.$i;
        }
        $value = self::secC($value, $secKeyFileBasename, $SecIteration, $secPack, $secAlgorithm, $secBase64Encode);

        return $value;
    }

    private static function uuidCyptedSet($type, $i = 2) {

        return self::cryptSet($type, self::SEC_UUID_RAND_START, self::SEC_UUID_RAND_STOP,
            self::SEC_KEY_UUID_FILE_BASENAME, self::SEC_ITERATION_UUID, self::SEC_PACK_UUID,
            self::SEC_ALGORITHM_UUID, self::SEC_UUID_BASE_64_ENCODE, $i);
    }

    private static function pathCyptedSet($type, $i = 3) {

        return self::cryptSet($type, self::SEC_PATH_RAND_START, self::SEC_PATH_RAND_STOP,
            self::SEC_KEY_PATH_FILE_BASENAME, self::SEC_ITERATION_PATH, self::SEC_PACK_PATH,
            self::SEC_ALGORITHM_PATH, self::SEC_PATH_BASE_64_ENCODE, $i);
    }

    private static function uuidKeyGet($value) {

        return self::$keyList[$value];
    }

    private static function pathKeyGet($value) {

        return self::$keyList[$value];
    }

    public static function confToParamList($conf) {

        $paramList = array();

        foreach($conf->postNameList as $k => $v) {

            $paramList[$v] = $conf->postTypeList[$k];
        }
        return $paramList;
    }

    public static function attributAdd($conf) {

        if(isset(self::$attributList[$conf->return]) === true) {

            return false;
        }
        self::$attributList[$conf->return] = new Attribut($conf);

        return true;
    }

    public static function labelAdd($conf) {

        if(isset(self::$labelList[$conf->return]) === true) {

            return false;
        }
        self::$labelList[$conf->return] = new Label($conf);

        return true;
    }

    public static function microServiceAdd($name, $conf) {

        if(isset(self::$microServiceList[$name]) === true) {

            return false;
        }
        self::$microServiceList[$name] = new MicroService($name, $conf);

        return true;
    }

    public static function relationShipAdd($conf) {

        if(isset(self::$relationShipList[$conf->relationship]) === true) {

            return false;
        }
        self::$relationShipList[$conf->relationship] = new RelationShip($conf);

        return true;
    }

    public static function indexAdd($index) {

        if(isset(self::$indexList[$index]) === true) {

            return false;
        }
        self::$indexList[$index] = new Index($index);
        $conf                    = stdclass();
        $conf->return            = $index;
        $conf->returnType        = false;

        self::attributAdd($conf);

        return true;
    }

    public static function nodeAdd($conf, $labelConf) {

        self::labelAdd($labelConf);

        if(isset(self::$nodeList[$conf->return]) === true) {

            return false;
        }
        self::$nodeList[$conf->return] = new Node($conf);

        return true;
    }
}

?>