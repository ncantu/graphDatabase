<?php

class TraceView {
	
	use TTemplate;
	use TRequest;
	
	CONST APP_NAME             = 'traceView';
	CONST APP_CLASS            = 'traceView';
	CONST MAIN_TEMPLATE        = 'traceViewTemplate';
	CONST COUNT_SUFFIX         = 'Count';
	CONST COUNT_HTML_SUFFIX    = 'CountHtml';
	
	private $appNameSelected;
	private $mockSelected;
	private $stateSelected;
	private $userIdSelected;
	private $yearSelected;
	private $monthSelected;
	private $daySelected;
	private $hourSelected;
	private $classSelected;
	private $instanceSelected;
	private $lineSelected;
	private $methodSelected;
	private $envSelected;
	private $mockList;
	private $appList;
	private $stateList;
	private $classList;
	private $time;
	private $timeZone;
	private $filterList     = array('env', 'state', 'class', 'appName', 'mock', 'year', 'month', 'day', 'hour', 'userId', 'instance', 'line', 'method');
	private $filterDateList = array();
	private $listList       = array('env', 'mock', 'app', 'state', 'class');
	private $countHtml      = '';
	private $fileCount      = array();
	private $appCount       = array();
	private $userCount      = array();
	private $classCount     = array();
	private $appNameCount   = array();
	private $mockCount      = array();
	private $yearCount      = array();
	private $monthCount     = array();
	private $dayCount       = array();
	private $hourCount      = array();
	private $userIdCount    = array();
	private $instanceCount  = array();
	private $methodCount    = array();
	private $envCount       = array();
		
	public function __construct() {
		
		date_default_timezone_set(Conf::TIMEZONE_DEFAULT);
		
		$this->htmlGet();
		
		echo $this->html;
	}
	
	public function htmlGet() {
		
		$this->filterDateList['year']  = 'Y';
		$this->filterDateList['month'] = 'm';
		$this->filterDateList['day']   = 'd';
		$this->filterDateList['hour']  = 'H';
				
		foreach($this->filterList as $filter) {
			
			$varName         = $filter.self::SELECTED_SUFFIX;
			$filterName      = $filter.self::FILTER_SUFFIX;
			
			if(isset($this->filterDateList[$filter]) === false) $this->$varName  = self::filterExist($filterName);
			else                                                $this->$varName  = self::filterExist($filterName, date($this->filterDateList[$filter], time()));
		}
		foreach($this->listList as $list){
		
			$varName        = $list.self::LIST_SUFFIX;
			$funcName       = $list.self::LIST_HTML_GET_SUFFIX;
			$this->$varName = $this->$funcName();
		}
		$this->time		= date('d/m/Y H:i:s', time());
		$this->timeZone	= Conf::TIMEZONE_DEFAULT;
		$this->content  = $this->fileContentHtmlGet();

		foreach($this->filterList as $filter) {
						
			if($filter === 'state') continue;
			if($filter === 'line')  continue;
			
			$varName          = $filter.self::COUNT_SUFFIX;
			$this->countHtml .= '<h3>'.$filter.'</h3>';
			
			foreach($this->$varName as $value => $states) {
				
				$this->countHtml .= '<p>'.$value.': ';
				
				foreach($states as $state => $val) {
			
					$this->countHtml .= '<span class="'.$state.'">'.$state.'('.$val.')</span> ';
				}
				$this->countHtml .= '</p>';
			}
		}
		$this->html = $this->templateHtml();
		
		return $this->html;
	}
	
	private static function stateListHtmlGet() {
	
		return self::listHtmlGet(Trace::$stateList, $this->stateSelected, true);
	}
	
	private static function envListHtmlGet() {
	
		return self::listHtmlGet(array('dev', 'preproduction', 'production'), $this->envSelected, true);
	}
	
	private static function classListHtmlGet() {
	
		return self::listHtmlGet(Fw::$classList, $this->classSelected, true);
	}
	
	private function mockListHtmlGet() {

		$files2 = array();
		$files  = glob(Mock::DIR.'*'.Mock::FILE_EXT);
		
		sort($files);
		
		foreach($files as $file) {
				
			$file     = basename($file);
			$files2[] = str_replace(Mock::FILE_EXT, '', $file);
		}
		return self::listHtmlGet($files2, $this->mockSelected, true, true);
	}
	
	private function appListHtmlGet(){

		$files2 = array();
		$files  = glob(App::EXPLOIT_DIR.'*'.App::FILE_EXT);
		$files  = array_merge($files, glob(App::PUBLIC_DIR.'*'.App::FILE_EXT));
		
		sort($files);
		
		foreach($files as $file) {
				
			$file     = basename($file);
			$files2[] = str_replace(App::FILE_EXT, '', $file);
		}
		return self::listHtmlGet($files2, $this->appNameSelected, true);
	}
	
	private function fileContentHtmlGet() {
		
		$contentA = array();
		$files    = glob(Trace::DIR.'*'.Trace::FILE_EXT);
		
		rsort($files);
		
		foreach($files as $file) {
		
			$size      = filesize($file);
			$size      = $size / 1000000;
			$size      = round($size,3);
			$size      = (string) $size;
			$basenamme = basename($file);
			$content   = file_get_contents($file);
			$content   = trim($content);
			$content   = explode(Trace::SEP, $content);
			
			krsort($content);
			
			foreach($content as $l) {
				
				$l = trim($l);
				$l = str_replace(Trace::SEP_REPLACE, Trace::SEP, $l);
				$l = json_decode($l);
				
				foreach($l as $k => $v){
					
					if(is_string($v) === false) continue;
					
					if($v === Trace::VOID) {
						
						unset($l->$k);
						continue;
					}
					if(substr(strtolower($k), -5) === '_json') $l->$k = json_decode($v);
				}
				$env     = $l->env_name;
				$state   = $l->errorInfoLevel;
				$userId  = $l->u_idCryptedT;
				$appName = $l->app_name;
				$year    = $l->tY_Y;
				$month   = $l->tmon_m;
				$day     = $l->tdm_d;
				$hour    = $l->tH_H;
				$mock    = 'none';
				
				if($l->mock_state !== false) $mock = $l->mock_name;
				
				$time     = $l->t_time;
				$class    = $l->c_name;
				$line     = $l->l_number;
				$method   = $l->m_name;
				$instance = $l->i_name;
				$continue = false;
				
				foreach($this->filterList as $filter) {
						
					$varName = $filter.self::SELECTED_SUFFIX;
					$value   = ${$filter};
					
					if(self::isSelected($value, $this->$varName) === false) {
						
						$continue = true;
						break;
					}
				}
				if($continue === true) continue;
				
				$l                 = json_encode($l, JSON_PRETTY_PRINT);
				$l                 = htmlentities($l, ENT_HTML5);
				$title             = $basenamme.' '.$size.' Mo';
				$contentA[$time][] = '<p>'.$title.'<pre class="'.$state.'">'.$l.'</pre></p>';
				
				if($state !== 'startParam' && $state !== 'info') {
				
					foreach($this->filterList as $f) {
						
						if($f === 'state') continue;
						if($f === 'line')  continue;
						
						$vn = $f.self::COUNT_SUFFIX;
						
						if(isset($this->$vn[${$f}][$state]) === false) $this->$vn[${$f}][$state] = 0;
						
						$this->$vn[${$f}][$state]++;
					}
				}
			}
		}
		sort($contentA);

		$contentHTML = '';
		
		foreach($contentA as $time => $events){
			
			$contentHTML .= implode("\n", $events);
		}
		return $contentHTML;
	}
}

?>
